# Mega-CC aka "Взломщик кодов" (Mega Code Cracker)

## Проект альтернативного ПО для аппаратного чит-инструмента от Симба под названием "Взломщик кодов"

![mega-cc-gens](https://user-images.githubusercontent.com/24475390/186272296-618e13d9-3968-41a3-9e6d-8d3d696f2176.png)

#### Предыстория.

Данному проекту предшествовали изыскания, описанные в статье на моем сайте: [«Взломщик Кодов» Simba's - модификация и оптимизации](https://migera.ru/smd/mega-cc.html)

Также выходом в свет данный проект обязан другому моему проекту: [Продвинутая и расширенная редакция утилиты работы с интерфейсом (программатором) перезаписываемых Sega MegaDrive/Genesis картриджей – FlashKit MD](https://github.com/MiGeRA/FlashKit-MD-Plus)

#### Что уже есть и чем можем похвастаться:

В настоящий момент, спустя чуть больше недели после своего старта и меньше месяца после приобретения мной картриджа этого инструмента, данный проект можно считать завершенным на своей первой стадии.

Для использования ПО, предлагаемого данным проектом, необходимо внесение небольших, но важных изменений в аппаратную часть взломщика с полным сохранением обратной совместимости: вместо ПЗУ-однократки предлагается установить перезаписываемую flash-ПЗУ, а также обеспечить удобные средства для её программирования (см. ссылки выше). Впрочем, ничто не мешает прошить другую однократку в программаторе и запаять её (но так не интересно, и на будущее непрактично). 

Актуальная версия альтернативного ПО Mega-CC имеет ряд преимуществ перед стоковым ПО взломщика и поэтому в большинстве случаев его использование предпочтительнее (для меня уж точно) ...

+ Минималистичный и максимально быстродействующий интерфейс! Да это мега-благо! И это один из основных моментов подвигших меня на создание этого проекта. Никакой музыки и заставок – ничего лишнего вообще;
+ Для запуска игры может потребоваться лишь нажатие кнопки Старт – это займет не более пары секунд максимум (если не нужно менять содержание и набор активных кодов);
+ Пока реализован лишь режим ручного ввода кодов. Однако создание или миграция базы кодов в стоковой версии маппера и не планируется вовсе. Т.к. ценность базы внутри имхо может быть невелика (если искать игру дольше, чем вбить код) – куда как важнее возможность интуитивного и быстрого ввода нужных кодов перед запуском и сохранение введенных кодов при отключении питания … И сейчас это есть!
+ Почти полностью переписан обработчик патчинга (мини-подпрограмма - «довесок» к VInt) с целью оптимизации времени выполнения и полноты сохранения контекста прерванной программы! А также поддержки новых функции, а именно …
+ Введена функция задержки активации фризинга после запуска основной программы (игры) на картридже. В течение нескольких секунд (максимум до 5-ти, см. исходник – пока не выведено в интерфейс пользователя), фризинг дремлет, щелкая счетчиком по кадрам – это дает возможность отработать заставкам и прочим вступительным алгоритмам для которых патчинг может быть нежелательным (т.к. он не для них). Соответственно ряд игр теперь можно начинать штатно – а не выключать при запуске и включать обратно при прогрузке игры наш взломщик;
+ Также добавлен код приостанавливающий процессор Z80 на время работы патчера для минимизации звуковых артефактов (все это в асме – т.к. важна скорость: см. файлик sega.s). Не везде артефакты исчезли полностью – но это уже аппаратный нюанс и лучше чем сейчас быть на данном железе взломщика видимо не может (мгновенный обратный прыжок не минимизирует артефакты более …);
+ Добавлена проверка аппаратно-программной исправности ОЗУ взломщика при старте (о чем выводится информационная строчка), так же после проверки память полностью очищается (что удобно в дальнейшем);
+ Реализована функция энергонезависимого сохранения введенных кодов через самопрограммирование картриджа! Нажатием на центр крестовины осуществляется сохранение, а автоматическая загрузка сохраненного ранее - при каждом запуске (подробности см. ниже);
+ Да, управление ориентировано под классический «трехкнопочный» джойстик (для максимальной совместимости). При желании можно легко переназначить функции на дополнительные (другие) кнопки или их комбинации.

#### Самопрограммирование картриджа.

Удивительно, но, похоже, я первый в мире кто реализовал, в общем-то, такой незамысловатый и весьма полезный функционал в рамках подобного решения. Это в историческом прошлом (30 лет назад и более) картриджи, хранившие основную программу, как правило, в масочном ПЗУ были обречены иметь второй тип памяти на своем борту доступной также еще и для записи с целью хранения игровых состояний и рекордов в энергонезависимом режиме – если стояла такая задача. Как правило, это была микросхема статического ОЗУ с питанием от литиевой батарейки – такое решение было популярно в применении на многих платформах 80х-90х годов прошлого века. Но МегаДрайв и тут занимал лидирующие позиции! – некоторые игры на своих носителях имели уникальную в своем роде (даже по нынешним меркам) память т.н. FRAM. Это фактически тоже статическое ОЗУ, но не теряющее своего содержимого при отключении питания, а еще к тому же не требующее отдельных алгоритмов для его стирания или записи! – пишется как обычная SRAM. Фантастика, но технология оказалась дорогой и невостребованной по критерию объем/цена – увы, канула в лету. Но изящное решение совсем на поверхности! Ведь можно же обойтись все лишь одной микросхемой, но перезаписываемой – пусть и с несимметричными алгоритмами чтения/стирания/записи … Главное не с окошком чтоб, а электрически-стираемой, да еще и при штатном напряжении (т.е. не любая EEPROM подойдет, а вот т.н. «флэш» - вполне). И самое интересное, что подобные flash-ПЗУ фактически современники МегаДрайва! – но их не применяли в картриджах (не исключено что их цена превосходила даже цену FRAM вкупе с масочным ПЗУ). Сейчас же ретро-железо куда как более доступно, а поэтому я, как и многие гики-энтузиасты, воплощаю в жизнь технически правильные и изящные решения.
И так. Для энергонезависимого хранения изменяемого в процессе работы программы блока данных («игровое сохранение») достаточно иметь на картридже всего лишь одну микросхему! Текущая реализация альтернативного ПО для аппаратного чит-девайса «Взломщик кодов» может служить примером и отправной точкой для дальнейшего совершенствования и применения концепции внутрисхемного (внутрисистемного) программирования картриджа в приставке без какого-либо дополнительного оборудования (программатора) и ПО к нему. (Это почти как: «кто девушку кормит, тот и танцует» - так и микросхему flash-ПЗУ: главное «кормить» и командовать понятным ей набором слов, никакой магии и программатор отдельный не нужен.) Все достаточно просто: нужно лишь иметь ввиду и учитывать, что при стирании/записи («программировании») даже блоков flash-ПЗУ не задействованных основной программой – на это время становится недоступной для чтения ВСЯ микросхема! Таким образом, выполнение алгоритма, хранящегося в ней, будет нарушено если мы не предпримем один технологический приём: разместим (скопируем) процедуру реализующую функцию стирания/программирования в основном ОЗУ системы, а также предотвратим любые возможные обращения к формально временно отсутствующему ПЗУ (т.е. еще и прерывания запретим, и сопроцессор приостановим). Представленное решение хоть и выглядит незамысловато-примитивно, но придти к нему сишными конструкциями было очень непросто – это в асме легче многое сделать (SGDK терпишь только ради удобства интеграции графического контента).
Реализация же непосредственно алгоритма управления массивом памяти микросхемы не сложнее (а возможно даже проще – так как на единых шинах процессора всё и с максимальным быстродействием) чем создание софта под любой из программаторов (что для меня тоже уже дорожка проторенная): читая документацию на микросхему - транслируем алгоритм с английского на язык программирования.

#### Краткая памятка пользователю.

Несмотря на легенду внизу экрана, напишу тоже самое, но по-русски и чуть более развернуто. В текущей стартовой версии (1.0) предусмотрено использование до 10 «кодов», т.е. можно «заморозить» такое же количество байт в ОЗУ МегаДрайва. Формат кода состоит из адреса (два байта смещения в ОЗУ) и байта данных (который будет по данному адресу безустали записываться, вызывая эффект фриза). Адреса можно располагать в любом порядке, более того: строки можно пропускать также в любом порядке! Актуальными будут лишь те, напротив которых в квадратных скобках проставлен символ звездочки (варьируется кнопкой C при курсоре на любой из цифр в данной строке). Строка (код) активируется автоматически при изменении любой из цифр в данной строке – для этого служат кнопки A и B, которые соответственно инкрементируют или декрементируют цифру под курсором (с переносом или заёмом в/из соседнего разряда при переполнении – обычная арифметика). Навигация курсора крестовиной с зацикливанием через края. Кнопка Старт передает управление картриджу в слоте с инициализацией в работу активных кодов.
Для удобства редактирования есть возможность обнуления кода (текущей строки) – комбинация A + B. При запуске ПО взломщика из области flash-ПЗУ (начало 128-ого килобайта) считывается сохраненная там ранее таблица кодов (если содержимое области отлично от чистого состояния 0xFF). Т.е. при старте происходит автозагрузка. Её как обычно можно отредактировать и при желании сохранить обратно, нажав на центр крестовины джойстика (все четыре кнопки направлений одновременно). В случае если обнаружен поддерживаемый тип микросхемы памяти (пока это Intel PA28F400 или PA28F200) – будет произведена попытка ее очистки и перезаписи (лишь одного блока микросхемы). Если операция стирания провалилась (вдруг, как вариант: питание заниженным оказалось) – смысла пытаться дальше писать нет, выводится сообщение об ошибке, программа зависнуть не должна (в теории). После завершения записи происходит повторное считывание таблицы: её неизменность на экране – гарантия успешной записи. Запуск игры и коды активные в ней не привязаны к хранящейся во flash-ПЗУ таблице: т.е. можно как записать введенные коды перед запуском игры (чтоб повторно их не вбивать потом), так и не делать этого (таблица с активными кодами будет применена только для конкретного старта). Вобщем хозяин–барин экспериментируйте :-)

#### Планы по дальнейшему развитию.
Проект на данном этапе, т.е. в стоковой аппаратной реализации, можно считать завершенным …
Поэтому первым делом дальше нужно будет обкатать создание и применение новой конфигурации CPLD вместе с обновлением самой CPLD:
+ Выпаиваем и монтируем панельку PLCC-44 на плату взломщика (а вместе с этим создаем отладочный адаптер для прошивки CPLD древнейшего семейства MAX-7000);
+ Создаем конфигурацию, повторяющую имеющийся функционал (т.к. у нас будет полная обратная совместимость!);
+ Фантазируем с расширенным функционалом (места должно хватить, ведь вместо стоковой EPM7032 будет применена EPM7064 - не густо, но в два раза больше): первое и основное – при старте маппить память картриджа в адресное пространство с 4-ого по 8-ой мегабайты (а-ля которое под «второй слот» и CD-ROM иже с ним). Это даст нам возможность не только читать идентификатор игры вставленного картриджа (и делать выборку из базы, например), но и внутрисистемно записывать флэш-картриджи! Интерфейсом связи с компом может быть любой схемотехнически-простейший интерфейс (хоть через порт джойстика) – ведь у нас памяти для буферизации достаточно. В итоге программатором флэш-картриджей будет сам МегаДрайв: софт для него в памяти взломщика и клиентская софтина на ПК, а также прошивка в контроллере, сопрягающем USB и порт джойстика (если какого-нибудь FTDI будет недостаточно).

Внимательный продолжатель данного проекта наверняка заметит конструкции не используемые сейчас: это или альтернативы имеющимся (которым нашлись лучшие имхо варианты), или пригожие для последующего развития (закомментированы или просто алгоритмически пустуют);

Проект написан с использованием SGDK (1.65) в MS Visual Studio Code и полностью открыт (GNU GPL).

PS. Кому не вникать, а сразу воспользоваться - скомпилированный [бинарник](https://github.com/MiGeRA/Mega-CC/blob/master/out/rom.bin).

